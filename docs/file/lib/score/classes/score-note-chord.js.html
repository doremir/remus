<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">lib/score/classes/score-note-chord.js | remus</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Generalized music representation"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="remus"><meta property="twitter:description" content="Generalized music representation"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#classes">classes</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/audio-file.js~AudioFile.html">AudioFile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/duration.js~Duration.html">Duration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/harmony.js~Harmony.html">Harmony</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/interval.js~Interval.html">Interval</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/item.js~Item.html">Item</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/mode.js~Mode.html">Mode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/pitch.js~Pitch.html">Pitch</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/syllable.js~Syllable.html">Syllable</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#classes-event">classes/event</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/event/audio.js~Audio.html">Audio</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/event/chord-sequence.js~ChordSequence.html">ChordSequence</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/event/chord.js~Chord.html">Chord</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/event/event-container.js~EventContainer.html">EventContainer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/event/event.js~Event.html">Event</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/event/note-chord.js~NoteChord.html">NoteChord</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/event/note.js~Note.html">Note</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/event/rest.js~Rest.html">Rest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/event/song.js~Song.html">Song</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/event/tuplet.js~Tuplet.html">Tuplet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/event/vertical-container.js~VerticalContainer.html">VerticalContainer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/event/voice-container.js~VoiceContainer.html">VoiceContainer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/event/voice.js~Voice.html">Voice</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#classes-meta">classes/meta</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/meta/clef.js~Clef.html">Clef</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/meta/key.js~Key.html">Key</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/meta/meta.js~Meta.html">Meta</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/meta/tempo.js~Tempo.html">Tempo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/classes/meta/time.js~Time.html">Time</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#score">score</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/score/score.js~Score.html">Score</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#score-classes">score/classes</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/score/classes/score-bar.js~ScoreBar.html">ScoreBar</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/score/classes/score-bracket.js~ScoreBracket.html">ScoreBracket</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/score/classes/score-clef.js~ScoreClef.html">ScoreClef</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/score/classes/score-detail.js~ScoreDetail.html">ScoreDetail</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/score/classes/score-event.js~ScoreEvent.html">ScoreEvent</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/score/classes/score-item.js~ScoreItem.html">ScoreItem</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/score/classes/score-key.js~ScoreKey.html">ScoreKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/score/classes/score-meta.js~ScoreMeta.html">ScoreMeta</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/score/classes/score-note-chord.js~ScoreNoteChord.html">ScoreNoteChord</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/score/classes/score-note.js~ScoreNote.html">ScoreNote</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/score/classes/score-rest.js~ScoreRest.html">ScoreRest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/score/classes/score-syllable.js~ScoreSyllable.html">ScoreSyllable</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/score/classes/score-tie.js~ScoreTie.html">ScoreTie</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/score/classes/score-time.js~ScoreTime.html">ScoreTime</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/score/classes/score-tuplet.js~ScoreTuplet.html">ScoreTuplet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/score/classes/staff-system.js~StaffSystem.html">StaffSystem</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/score/classes/score-note-chord.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import ScoreEvent from &apos;./score-event.js&apos;;

export default class ScoreNoteChord extends ScoreEvent {

  //  Calculates the default stem direction, the rule are the same
  //  regardles of if the notes are on the same stem or in the same beam:
  //  The note farthest away from the middle line determines the stem direction.
  //  in case of a tie, down is favoured.
  defaultStemDirection() {
    let min = this.notes[0].staffLine;
    let max = this.notes[this.notes.length - 1].staffLine;
    // for (let note of this.notes) {
    //   min = Math.min(min, note.staffLine);
    //   max = Math.max(max, note.staffLine);
    // }
    let furthest = (Math.abs(min) &gt; Math.abs(max)) ? min : max;
    return furthest &gt; 0 ? &apos;up&apos; : &apos;down&apos;;
  }

  innerWidth() {
    return Math.max(...this.notes.map(n =&gt; n._notehead.bbox.bBoxNE[0]));
  }

  boundingBox() {
    return {
      left: -this.leftExtent,
      top: this.stem.direction === &apos;up&apos; ? this.stem.end : this.stem.extent,
      right: this.innerWidth() + this.rightExtent,
      bottom: this.stem.direction === &apos;up&apos; ? this.stem.extent : this.stem.end
    };
  }

  updateExtents() {
    let staffSpace = this.score.staffSize * 0.25;
    this.leftExtent = this.accidentalX || 0;
    let flagExtent = this.flags &amp;&amp; !this.beam ? 1 * staffSpace : 0;
    let dotExtent = this.dots * staffSpace * this.score.musicFontMetadata.glyphBBoxes[&apos;augmentationDot&apos;].bBoxNE[0] * 2;
    this.rightExtent = Math.max(flagExtent, dotExtent);
  }

/**
 *  Returns the y coordinate (in staff spaces) of the stem start (at a note head)
 *  &gt; 1 notes and stem direction are taken into account
 *
 *  As a secondary value, returns the y coordinate of the outermost edge of the outermost notehead
 *  (usable for calculating the bounding box)
*/
  getStemStart() {
    let notes = this.notes;
    // TODO: use notehead metrics
    if (this.stem.direction === &apos;up&apos;) {
      let note = notes[notes.length - 1];
      let y = note.visibleYPos();
      return {
        start: y,
        extent: y + 0.5
      };
    } else {
      let note = notes[0];
      let y = note.visibleYPos();
      return {
        start: y,
        extent: y - 0.5
      };
    }
  }

 /**
  *  Returns the y coordinate of the stem end (in staff spaces), as if the event is not beamed
  *  &gt; 1 notes and stem direction are taken into account
  */
  getStemEnd() {
    let notes = this.notes;
    let note;
    let spacePerFlag = 1;

    if (notes.length &gt; 1) {
      note = this.stem.direction === &apos;up&apos; ? notes[0] : notes[notes.length - 1];
    } else {
      note = notes[0];
    }

    // Special case: whole notes don&apos;t have a stem
    if (this.noteValue === &apos;w&apos;) {
      return note.visibleYPos() + this.stem.direction === &apos;up&apos; ? -0.5 : 0.5;
    }

    // Manual stem length
    // if () {
    //
    // }

    // Stem up
    if (this.stem.direction === &apos;up&apos;) {
      // Default is one octave = 3.5 spaces, but shorter stem when note is above the middle staff line
      let result = note.visibleYPos() + (note.staffLine &lt; 0 ? -2.7 : -3.5);
      // Add space for each flag/beam after the first two
      if (this.flags &gt; 2) {
        result -= (this.flags - 2) * spacePerFlag;
      }
      // Stem goes at least to the middle staff line
      if (note.staffLine &gt; 0) {
        result = Math.min(result, 0);
      }
      return result;
    } else {
      // Stem down
      // Default is one octave = 3.5 spaces, but shorter stem when note is below the middle staff line
      let result = note.visibleYPos() + (note.staffLine &gt; 0 ? 2.7 : 3.5);
      // Add space for each flag/beam after the first two
      if (this.flags &gt; 2) {
        result += (this.flags - 2) * spacePerFlag;
      }
      // Stem goes at least to the middle staff line
      if (note.staffLine &lt; 0) {
        result = Math.max(result, 0);
      }
      return result;
    }
  }

  draw(ctx) {
    ctx.save();
    ctx.lineCap = &apos;butt&apos;;
    ctx.fillStyle = this.defaultColor();

    let staffSpace = this.score.staffSize * 0.25;
    let stemThickness = staffSpace * (this.score.engravingDefaults.stemThickness || 0.12);
    let beamThickness = staffSpace * (this.score.engravingDefaults.beamThickness || 0.5);
    let beamSpacing = staffSpace * (this.score.engravingDefaults.beamSpacing || 0.25);
    let xAdjust = stemThickness * 0.5;

    // Draw notes and collect info about y positions
    let min = this.notes[0].staffLine;
    let max = this.notes[0].staffLine;
    for (let note of this.notes) {
      min = Math.min(min, note.staffLine);
      max = Math.max(max, note.staffLine);
      note.draw(ctx);
    }

    // Draw leger lines if needed
    if (min &lt;= -3) {
      min = Math.ceil(min);
      ctx.beginPath();
      for (let i = -3; i &gt;= min; i--) {
        ctx.moveTo(this.scoreX - 2, this.staffY + i * staffSpace);
        ctx.lineTo(this.scoreX + 10, this.staffY + i * staffSpace);
      }
      ctx.lineWidth = staffSpace * (this.score.engravingDefaults.legerLineThickness || 0.16);
      ctx.stroke();
    }
    if (max &gt;= 3) {
      max = Math.floor(max);
      ctx.beginPath();
      for (let i = 3; i &lt;= max; i++) {
        ctx.moveTo(this.scoreX - 2, this.staffY + i * staffSpace);
        ctx.lineTo(this.scoreX + 10, this.staffY + i * staffSpace);
      }
      ctx.lineWidth = staffSpace * (this.score.engravingDefaults.legerLineThickness || 0.16);
      ctx.stroke();
    }

    // Draw stem and flags
    ctx.lineWidth = stemThickness;
    if (this.noteValue === &apos;w&apos;) {
      // No stem
    } else if (this.stem.direction === &apos;up&apos;) {
      let x = this.scoreX + (this.stemX || 0);
      // Stem
      // Small adjustment: if there is a beam and it is sloped, the outermost stem will be a little too long.
      // We compensate by shortening the stem. Instead of calculating an exact amount,
      // we trust that the stem end will be covered by the beam anyway.
      let stemEnd = this.stem.end + (this.beam ? 0.25 : 0);
      ctx.beginPath();
      ctx.moveTo(x, this.staffY + staffSpace * this.stem.start);
      ctx.lineTo(x, this.staffY + staffSpace * stemEnd);
      ctx.stroke();
      // Flag
      if (!this.beam) {
        x -= xAdjust; // correct?
        switch (this.noteValue) {
          case &apos;8&apos;: ctx.fillText(&apos;\uE240&apos;, x, this.staffY + staffSpace * this.stem.end); break;
          case &apos;16&apos;: ctx.fillText(&apos;\uE242&apos;, x, this.staffY + staffSpace * this.stem.end); break;
          case &apos;32&apos;: ctx.fillText(&apos;\uE244&apos;, x, this.staffY + staffSpace * this.stem.end); break;
          case &apos;64&apos;: ctx.fillText(&apos;\uE246&apos;, x, this.staffY + staffSpace * this.stem.end); break;
        }
      }
    } else {
      let x = this.scoreX + (this.stemX || 0);
      // Stem
      let stemEnd = this.stem.end - (this.beam ? 0.25 : 0);
      ctx.beginPath();
      ctx.moveTo(x, this.staffY + staffSpace * this.stem.start);
      ctx.lineTo(x, this.staffY + staffSpace * stemEnd);
      ctx.stroke();
      // Flag
      if (!this.beam) {
        x -= xAdjust; // correct?
        switch (this.noteValue) {
          case &apos;8&apos;: ctx.fillText(&apos;\uE241&apos;, x, this.staffY + staffSpace * this.stem.end); break;
          case &apos;16&apos;: ctx.fillText(&apos;\uE243&apos;, x, this.staffY + staffSpace * this.stem.end); break;
          case &apos;32&apos;: ctx.fillText(&apos;\uE245&apos;, x, this.staffY + staffSpace * this.stem.end); break;
          case &apos;64&apos;: ctx.fillText(&apos;\uE247&apos;, x, this.staffY + staffSpace * this.stem.end); break;
        }
      }
    }

    // Draw beams
    if (this.beam &amp;&amp; this.beam.events[0] === this) {
      let beamEvents = this.beam.events;
      let firstEvent = beamEvents[0];
      let lastEvent = beamEvents[beamEvents.length - 1];
      let firstX = firstEvent.x + (firstEvent.stemX || 0);
      let lastX = lastEvent.x + (lastEvent.stemX || 0);
      let firstY = this.staffY + staffSpace * firstEvent.stem.end;
      let lastY = this.staffY + staffSpace * lastEvent.stem.end;
      let slope = (lastY - firstY) / (lastX - firstX);

      if (this.stem.direction === &apos;down&apos;) firstY -= beamThickness;

      // console.log(&apos;Drawing beam: &apos;, this.beam, firstY, lastY, this.staffY, slope, firstX, lastX);
      for (let level of this.beam.beams) {
        // console.log(&apos;  Level: &apos;, level);
        for (let beam of level) {
          let event1 = beam[0];
          let event2 = beam[beam.length - 1];
          let x1 = event1.x + (event1.stemX || 0) - xAdjust;
          let x2 = event2.x + (event2.stemX || 0) + xAdjust;

          // Beamlet
          // TODO: make sure they always point in the correct direction
          if (event1 === event2) {
            if (event1 === firstEvent) {
              x2 = x1 + staffSpace * 1.1;
            } else {
              x1 = x2 - staffSpace * 1.1;
            }
          }

          let y1 = firstY + (x1 - firstX) * slope;
          let y2 = firstY + (x2 - firstX) * slope;

          // console.log(&apos;  Drawing [&apos; + x1 + &apos; &apos; + y1 + &apos; &apos; + x2 + &apos; &apos; + y2 + &apos;]&apos;);

          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.lineTo(x2, y2 + beamThickness);
          ctx.lineTo(x1, y1 + beamThickness);
          ctx.closePath();
          ctx.fill();
        }
        if (this.stem.direction === &apos;up&apos;) {
          firstY += beamThickness + beamSpacing;
        } else {
          firstY -= beamThickness + beamSpacing;
        }
      }
    }
    ctx.restore();
  }

  toSVG(svg) {
    svg.fill(this.defaultColor());
    svg.addClass(&apos;ScoreNoteChord&apos;);
    svg.addClass(&apos;voice-&apos; + this.voice.id);
    // lineCap = &apos;butt&apos;;

    let score = this.score;
    let staffSpace = score.staffSize * 0.25;
    let stemThickness = staffSpace * (score.engravingDefaults.stemThickness || 0.12);
    let beamThickness = staffSpace * (score.engravingDefaults.beamThickness || 0.5);
    let beamSpacing = staffSpace * (score.engravingDefaults.beamSpacing || 0.25);
    let xAdjust = stemThickness * 0.5;

    // Draw notes and collect info about y positions
    let min = this.notes[0].staffLine;
    let max = this.notes[0].staffLine;
    for (let note of this.notes) {
      min = Math.min(min, note.staffLine);
      max = Math.max(max, note.staffLine);
      let group = svg.group();
      note.toSVG(group);
      group.addClass(&apos;ScoreNote&apos;);
      group.addClass(&apos;voice-&apos; + this.voice.id);
      // Add references
      note.svgElement = group;
      score.itemsBySVGID[group.id()] = note;
      // Attach message handlers
      group.on(&apos;mouseenter&apos;, score.handleMouseEnter.bind(score));
      group.on(&apos;mouseleave&apos;, score.handleMouseLeave.bind(score));
      group.on(&apos;click&apos;, score.handleClick.bind(score));
    }

    // Draw syllables
    for (let syllable of this.syllables) {
      let group = svg.group();
      syllable.toSVG(group);
      group.addClass(&apos;ScoreSyllable&apos;);
      group.addClass(&apos;ScoreItem&apos;);
      // Add references
      syllable.svgElement = group;
      score.itemsBySVGID[group.id()] = syllable;
      // Attach message handlers
      group.on(&apos;mouseenter&apos;, score.handleMouseEnter.bind(score));
      group.on(&apos;mouseleave&apos;, score.handleMouseLeave.bind(score));
      group.on(&apos;click&apos;, score.handleClick.bind(score));
    }

    // Draw leger lines if needed
    if (min &lt;= -3) {
      min = Math.ceil(min);
      let legerLines = svg.group().stroke({width: staffSpace * (this.score.engravingDefaults.legerLineThickness || 0.16)});
      let ext = staffSpace * (this.score.engravingDefaults.legerLineExtension || 0.4);
      for (let i = -3; i &gt;= min; i--) {
        legerLines.line(this.scoreX - ext, this.staffY + i * staffSpace, this.scoreX + this.innerWidth() * staffSpace + ext, this.staffY + i * staffSpace);
      }
    }
    if (max &gt;= 3) {
      max = Math.floor(max);
      let legerLines = svg.group().stroke({width: staffSpace * (this.score.engravingDefaults.legerLineThickness || 0.16)});
      let ext = staffSpace * (this.score.engravingDefaults.legerLineExtension || 0.4);
      for (let i = 3; i &lt;= max; i++) {
        legerLines.line(this.scoreX - ext, this.staffY + i * staffSpace, this.scoreX + this.innerWidth() * staffSpace + ext, this.staffY + i * staffSpace);
      }
    }

    // Draw stem and flags
    if (this.noteValue === &apos;w&apos;) {
      // No stem for whole notes
    } else if (this.stem.direction === &apos;up&apos;) {
      let x = this.scoreX + (this.stemX || 0);
      // Stem
      // Small adjustment: if there is a beam and it is sloped, the outermost stem will be a little too long.
      // We compensate by shortening the stem. Instead of calculating an exact amount,
      // we trust that the stem end will be covered by the beam anyway.
      let stemEnd = this.stem.end + (this.beam ? 0.25 : 0);
      let line = svg.line(x, this.staffY + staffSpace * this.stem.start, x, this.staffY + staffSpace * stemEnd).addClass(&apos;stem&apos;);
      line.stroke({width: stemThickness});
      // Flag
      if (!this.beam) {
        x -= xAdjust; // correct?
        let y = this.staffY + staffSpace * this.stem.end;
        switch (this.noteValue) {
          case &apos;8&apos;: svg.plain(&apos;\uE240&apos;).x(x).attr(&apos;y&apos;, y).font({family: null, size: null}); break;
          case &apos;16&apos;: svg.plain(&apos;\uE242&apos;).x(x).attr(&apos;y&apos;, y).font({family: null, size: null}); break;
          case &apos;32&apos;: svg.plain(&apos;\uE244&apos;).x(x).attr(&apos;y&apos;, y).font({family: null, size: null}); break;
          case &apos;64&apos;: svg.plain(&apos;\uE246&apos;).x(x).attr(&apos;y&apos;, y).font({family: null, size: null}); break;
          case &apos;128&apos;: svg.plain(&apos;\uE248&apos;).x(x).attr(&apos;y&apos;, y).font({family: null, size: null}); break;
          case &apos;256&apos;: svg.plain(&apos;\uE24A&apos;).x(x).attr(&apos;y&apos;, y).font({family: null, size: null}); break;
        }
      }
    } else {
      let x = this.scoreX + (this.stemX || 0);
      // Stem
      let stemEnd = this.stem.end - (this.beam ? 0.25 : 0);
      let line = svg.line(x, this.staffY + staffSpace * this.stem.start, x, this.staffY + staffSpace * stemEnd).addClass(&apos;stem&apos;);
      line.stroke({width: stemThickness});
      // // Flag
      if (!this.beam) {
        x -= xAdjust; // correct?
        let y = this.staffY + staffSpace * this.stem.end;
        switch (this.noteValue) {
          case &apos;8&apos;: svg.plain(&apos;\uE241&apos;).x(x).attr(&apos;y&apos;, y).font({family: null, size: null}); break;
          case &apos;16&apos;: svg.plain(&apos;\uE243&apos;).x(x).attr(&apos;y&apos;, y).font({family: null, size: null}); break;
          case &apos;32&apos;: svg.plain(&apos;\uE245&apos;).x(x).attr(&apos;y&apos;, y).font({family: null, size: null}); break;
          case &apos;64&apos;: svg.plain(&apos;\uE247&apos;).x(x).attr(&apos;y&apos;, y).font({family: null, size: null}); break;
          case &apos;128&apos;: svg.plain(&apos;\uE249&apos;).x(x).attr(&apos;y&apos;, y).font({family: null, size: null}); break;
          case &apos;256&apos;: svg.plain(&apos;\uE24B&apos;).x(x).attr(&apos;y&apos;, y).font({family: null, size: null}); break;
        }
      }
    }

    // Draw beams
    if (this.beam &amp;&amp; this.beam.events[0] === this) {
      let beamEvents = this.beam.events;
      let firstEvent = beamEvents[0];
      let lastEvent = beamEvents[beamEvents.length - 1];
      let firstX = firstEvent.x + (firstEvent.stemX || 0);
      let lastX = lastEvent.x + (lastEvent.stemX || 0);
      let firstY = this.staffY + staffSpace * firstEvent.stem.end;
      let lastY = this.staffY + staffSpace * lastEvent.stem.end;
      let slope = (lastY - firstY) / (lastX - firstX);

      if (this.stem.direction === &apos;down&apos;) firstY -= beamThickness;

      // console.log(&apos;Drawing beam: &apos;, this.beam, firstY, lastY, this.staffY, slope, firstX, lastX);
      for (let level of this.beam.beams) {
        // console.log(&apos;  Level: &apos;, level);
        for (let beam of level) {
          let event1 = beam[0];
          let event2 = beam[beam.length - 1];
          let x1 = event1.x + (event1.stemX || 0) - xAdjust;
          let x2 = event2.x + (event2.stemX || 0) + xAdjust;

          // Beamlet
          // TODO: make sure they always point in the correct direction
          if (event1 === event2) {
            if (event1 === firstEvent) {
              x2 = x1 + staffSpace * 1.1;
            } else {
              x1 = x2 - staffSpace * 1.1;
            }
          }

          let y1 = firstY + (x1 - firstX) * slope;
          let y2 = firstY + (x2 - firstX) * slope;

          // console.log(&apos;  Drawing [&apos; + x1 + &apos; &apos; + y1 + &apos; &apos; + x2 + &apos; &apos; + y2 + &apos;]&apos;);

          svg.path([
            &apos;M&apos;, x1, y1,
            &apos;L&apos;, x2, y2,
            &apos;L&apos;, x2, y2 + beamThickness,
            &apos;L&apos;, x1, y1 + beamThickness,
            &apos;Z&apos;]).fill();
        }
        if (this.stem.direction === &apos;up&apos;) {
          firstY += beamThickness + beamSpacing;
        } else {
          firstY -= beamThickness + beamSpacing;
        }
      }
    }
  }

  toString() {
    return `[ScoreNoteChord (${this.notes.length})]`;
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
